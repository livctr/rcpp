"""
Main file for RCPP algorithm. 
"""
from typing import List, Tuple

from rcpp.width_calculator import WidthCalculator
from rcpp.risk_measure import RiskMeasure
from rcpp.performativity_simulator import PerformativitySimulator
from rcpp.loss_simulator import LossSimulator

import numpy as np
from tqdm import tqdm

import matplotlib.pyplot as plt
import numpy as np
from typing import List
import os


class Trajectory:
    def __init__(self, lambda_hat, risks_tt, risks_tm1_t, lambdas, guaranteed_T, delta_lambda):
        self.lambda_hat = np.array(lambda_hat)
        self.risks_tt = np.array(risks_tt)
        self.risks_tm1_t = np.array(risks_tm1_t)
        self.lambdas = np.array(lambdas)
        self.guaranteed_T = guaranteed_T
        self.delta_lambda = delta_lambda
    
    def __repr__(self):
        return (f"Trajectory(lambda_hat={self.lambda_hat}, "
                f"num_iterations={len(self.lambdas)-1}, "
                f"final_risk={self.risks_tt[-1]:.4f}, "
                f"guaranteed_T={self.guaranteed_T}, "
                f"delta_lambda={self.delta_lambda:.6f})")


def binary_search_solver(objective, lambda_low, lambda_high, tol=1e-6, max_iter=100) -> float:
    if objective(lambda_low) <= 0:
        return lambda_low

    if objective(lambda_high) > 0:
        raise ValueError("No crossing found: objective > 0 for all λ in [lambda_low, lambda_high].")

    for _ in range(max_iter):
        mid = (lambda_low + lambda_high) / 2.0
        if objective(mid) <= 0:
            lambda_high = mid
        else:
            lambda_low = mid
        if lambda_high - lambda_low < tol:
            break
    return lambda_high


def find_guaranteed_T(
    width_calculator: WidthCalculator,
    delta: float,
    N: int,
    tightness: float,
    tau: float,
    lambda_range: float,
    max_T: int = 10000) -> Tuple[int, float]:
    """
    Searches 1 through T for the minimum number of iterations for guaranteed convergence .
    """
    best_T = None

    for T in range(1, max_T + 1):
        width = width_calculator.get_width(delta / T, N)
        delta_lambda = (tightness - 2. * width) / (2. * tau)

        if delta_lambda < float(lambda_range) / T:
            continue

        best_T = T
        break

    if best_T is None:
        raise ValueError(f"Tightness {tightness} cannot be achieved in {max_T} iterations. width@{max_T} = {width}. {tightness - 2. * width}")

    return best_T, delta_lambda


def split(Z, idx):
    """
    Splits a list of lists or a list of NumPy arrays into two parts
    based on a given set of indices `idx`.

    Args:
        Z (list): A list where each element is either a Python list or a NumPy array.
                  All inner elements (lists/arrays) are assumed to have the same length.
        idx (np.ndarray): A 1D NumPy array of integers, representing the indices
                          to be included in Z_test. These indices are typically
                          generated by np.random.choice.

    Returns:
        tuple: A tuple (Z_cal, Z_test) where:
               - Z_cal (list): Contains elements NOT at the indices specified by `idx`.
               - Z_test (list): Contains elements AT the indices specified by `idx`.
               The elements within Z_cal and Z_test will maintain their original
               Python list or NumPy array type.
    """
    Z_cal = []
    Z_test = []

    # Determine the type of the inner elements (list or numpy array)
    is_numpy_array = False
    if len(Z) > 0 and isinstance(Z[0], np.ndarray):
        is_numpy_array = True

    # Get the total number of elements in each inner list/array
    if len(Z) > 0:
        total_elements_in_inner = len(Z[0])
    else:
        # If Z is empty, both Z_cal and Z_test will be empty lists
        return [], []

    # Create a boolean mask for efficient splitting
    # This mask will be True for elements to be kept in Z_cal
    # and False for elements to be moved to Z_test
    mask_for_cal = np.ones(total_elements_in_inner, dtype=bool)
    mask_for_cal[idx] = False # Set indices in `idx` to False

    for i in range(len(Z)):
        current_data = Z[i]

        if is_numpy_array:
            # For NumPy arrays, use boolean indexing directly
            Z_cal.append(current_data[mask_for_cal])
            Z_test.append(current_data[idx]) # Fancy indexing for selected elements
        else:
            # For Python lists, iterate and build new lists
            current_cal_list = []
            current_test_list = []
            for j in range(total_elements_in_inner):
                if mask_for_cal[j]:
                    current_cal_list.append(current_data[j])
                else:
                    current_test_list.append(current_data[j])
            Z_cal.append(current_cal_list)
            Z_test.append(current_test_list)

    return Z_cal, Z_test


def run_trajectory(
    data_generator,
    splitter,
    width_calculator: WidthCalculator,
    risk_measure: RiskMeasure,
    performativity_simulator: PerformativitySimulator,
    loss_simulator: LossSimulator,
    args,
) -> Trajectory:
  
    performativity_simulator.reset()

    # 1. Initialize lambda^{(0)}
    lambda_ = args.lambda_safe  # initialize the deployment threshold
    lambda_hat = lambda_       # deployment threshold to return

    control_risk = args.tau > 0
    if control_risk:  # Controlling risk
        # 2. Jointly solve for T, delta_prime, and delta_lambda
        tilde_T, delta_lambda = find_guaranteed_T(
            width_calculator,
            args.delta, args.N, args.tightness, args.tau, args.lambda_safe - args.lambda_min
        )
        bound = width_calculator.get_width(args.delta / tilde_T, args.N)
    else:
        tilde_T, delta_lambda = -1, -1

    lambdas = [lambda_]
    risks_tt = []
    risks_tm1_t = []
    iter = 0

    while True:
        # 4. Apply previous threshold lambda^{(t-1)}
        Z_base = next(data_generator)
        # _, Z_test = splitter(Z_base)
        Z_tm1 = performativity_simulator.simulate_shift(Z_base, lambda_)
        Z_cal_tm1, Z_test_tm1 = splitter(Z_tm1)

        # [tracking] Calculate the realized risk \hat{R}(lambda^{(t-1)}, lambda^{(t-1)})
        risks_tt.append(
            risk_measure.calculate(
                loss_simulator.calc_loss(Z_test_tm1, lambda_, do_new_sample=True)
            )
        )

        # # 4. Receive samples from previous threshold lambda^{(t-1)}

        # 5. Find lambda^{(t)}_new
        if control_risk:
            def loss_at_new_lambda(lambda_new):
                losses = loss_simulator.calc_loss(Z_cal_tm1, lambda_new, do_new_sample=False)
                emp_risk = risk_measure.calculate(losses)
                return emp_risk + bound + args.tau * (lambda_ - lambda_new) - args.alpha
            loss_simulator.calc_loss(Z_cal_tm1, lambda_, do_new_sample=True)  # Set the randomness
            lambda_mid = binary_search_solver(loss_at_new_lambda, 0, 1)
            lambda_new = min(lambda_, lambda_mid)
        else:
            lambda_new = 0.0
        lambdas.append(lambda_new)

        # [tracking] Calculate the realized risk \hat{R}(lambda^{(t-1)}, lambda^{(t)})
        risks_tm1_t.append(
            risk_measure.calculate(
                loss_simulator.calc_loss(Z_test_tm1, lambda_new, do_new_sample=True)
            )
        )

        # 7-8. Stopping condition 
        if control_risk and lambda_new >= lambda_ - delta_lambda:
            lambda_hat = lambda_new
            break
        if not control_risk:
            lambda_hat = lambda_new
            break

        lambda_ = lambda_new
        iter += 1

    # Calculate the \hat{R}(lambda_hat, lambda_hat)
    Z_base = next(data_generator)
    Z_test = performativity_simulator.simulate_shift(Z_base, lambda_hat)
    _, Z_test_test = splitter(Z_test)

    risks_tt.append(
        risk_measure.calculate(
            loss_simulator.calc_loss(Z_test_test, lambda_hat, do_new_sample=True)
        )
    )

    return Trajectory(
        lambda_hat=lambda_hat,
        risks_tt=risks_tt,
        risks_tm1_t=risks_tm1_t,
        lambdas=lambdas,
        guaranteed_T=tilde_T,
        delta_lambda=delta_lambda,
    )


def _tau_label(t) -> str:
    """Legend string for tau; τ=0 → 'no risk control'."""
    try:
        is_zero = float(t) == 0.0
    except Exception:
        is_zero = str(t).strip() in {"0", "0.0"}
    return "no risk control" if is_zero else rf"$\tau$ = {t}"


def plot_lambda_vs_iteration(
    taus: List[float],
    trajectories: List[List["Trajectory"]],
    colors: List[str],
    args,
    save_dir: str = "./figures",
    plot_all: bool = False,
):
    """
    Plot the trajectory of lambda over iterations for different tau values.

    Args
    ----
    taus: list of tau values (one per outer trajectories group).
    trajectories: list of lists; trajectories[i] is a list of Trajectory objects for taus[i].
                  Each Trajectory must expose:
                    - .lambdas: Sequence[float]
                    - .delta_lambda: float
    colors: list of colors; colors[i] is used for taus[i].
    args: object with attribute `lambda_safe` (float), used to set y-limits on the first plot.
    save_dir: directory to save output PDFs.
    plot_all: if True, plot every trajectory in each group; if False, only the first trajectory per group.
    """
    # ----------------------------- safety checks -----------------------------
    if len(taus) != len(trajectories):
        raise ValueError(f"len(taus)={len(taus)} must match len(trajectories)={len(trajectories)}")
    if len(colors) < len(trajectories):
        raise ValueError(f"Need at least {len(trajectories)} colors, got {len(colors)}")

    if save_dir:
        os.makedirs(save_dir, exist_ok=True)

    # ======================== Figure 1: λ_t vs iteration =====================
    plt.figure(figsize=(7, 4))
    # keep this to match your original behavior
    plt.ylim(0, getattr(args, "lambda_safe", 1.0))

    max_iters = 0
    for i, traj_list in enumerate(trajectories):
        subset = traj_list if plot_all else [traj_list[0]]
        # only label the first plotted line of each τ group
        label = _tau_label(taus[i]) if len(taus) > 1 else None


        for j, traj in enumerate(subset):
            plt.plot(
                traj.lambdas,
                label=label,
                color=colors[i],
                alpha=0.6 if plot_all else 1.0,
                linewidth=1.0 if plot_all else 1.5,
            )
            # mark the last point for each plotted trajectory
            if len(traj.lambdas) > 0:
                plt.scatter(
                    [len(traj.lambdas) - 1],
                    [traj.lambdas[-1]],
                    color=colors[i],
                    marker="x",
                    s=50,
                )
            label = None  # avoid duplicate legend labels within the same τ group
            max_iters = max(max_iters, len(traj.lambdas))

    plt.xlabel("Iteration", fontsize=20)
    plt.ylabel(r"$\lambda_t$", fontsize=20)
    # match your original tick style (step=2); guard against empty data
    step = 2
    if max_iters > 0:
        ticks = list(range(0, max_iters + 1, step))
        plt.xticks(ticks=ticks, labels=[str(t) for t in ticks], fontsize=14)
    plt.yticks(fontsize=14)

    all_lams = []
    for traj_list in trajectories:
        subset = traj_list if plot_all else [traj_list[0]]
        for traj in subset:
            if len(traj.lambdas):
                all_lams.extend(traj.lambdas)

    if all_lams:
        y_max = float(np.max(all_lams))
    else:
        y_max = float(getattr(args, "lambda_safe", 1.0))

    pad = max(1e-3, 0.03 * max(1.0, y_max))  # 3% or at least a tiny epsilon
    plt.ylim(-pad, y_max + pad)              # small negative bottom so 'x' at 0 is visible

    if len(taus) > 1:
        leg = plt.legend(loc="upper right")
        for lh in leg.legend_handles:
            lh.set_alpha(1)

    plt.grid(True)
    plt.tight_layout()
    if save_dir:
        save_path = os.path.join(save_dir, "lambda_vs_iteration.pdf")
        plt.savefig(save_path, dpi=300)
        print(f"Saved lambda plot to {save_path}")

    # ==================== Figure 2: |λ_{t} - λ_{t-1}| vs it. =================
    plt.figure(figsize=(7, 4))
    max_iters_diff = 0
    max_diff = 0

    for i, traj_list in enumerate(trajectories):
        subset = traj_list if plot_all else [traj_list[0]]
        label = _tau_label(taus[i]) if len(taus) > 1 else None

        for j, traj in enumerate(subset):
            lambdas = np.asarray(traj.lambdas, dtype=float)
            if lambdas.size < 2:
                # nothing to diff; skip cleanly
                label = None
                continue

            diffs = np.abs(np.diff(lambdas))
            xs = np.arange(1, len(diffs) + 1)

            plt.plot(
                xs,
                diffs,
                markersize=2,
                label=label,
                color=colors[i],
                alpha=0.6 if plot_all else 1.0,
                linewidth=1.0 if plot_all else 1.5,
            )
            # last-point marker for each trajectory's diff curve
            plt.scatter(xs[-1], diffs[-1], color=colors[i], marker="x", s=50)

            # per-trajectory delta line (kept from your version)
            plt.axhline(
                y=float(traj.delta_lambda),
                color=colors[i],
                linestyle="--",
                linewidth=1.5,
                alpha=0.7,
            )

            label = None
            max_iters_diff = max(max_iters_diff, len(diffs))
            max_diff = max(max_diff, np.max(diffs))

    plt.xlabel("Iteration", fontsize=20)
    if max_iters_diff > 0:
        ticks = list(range(0, max_iters_diff + 1, 2))
        plt.xticks(ticks=ticks, labels=[str(t) for t in ticks], fontsize=14)
    plt.yticks(fontsize=14)
    plt.ylabel(r"$|\lambda_{t} - \lambda_{t-1}|$", fontsize=20)
    plt.yscale("symlog", linthresh=1e-5)
    plt.ylim(bottom=-5e-6, top=max_diff * 2)

    plt.grid(True)
    plt.tight_layout()
    if save_dir:
        save_path = os.path.join(save_dir, "lambda_diff_vs_iteration.pdf")
        plt.savefig(save_path, dpi=300)
        print(f"Saved lambda diff plot to {save_path}")

def plot_loss_vs_iteration(
    tau: float,
    trajectories: List[Trajectory],
    color: str,
    args,
    save_dir: str = "./figures",
    show_tau_in_legend: bool = True
):
    plt.figure(figsize=(7, 4))

    tau_str = str(tau).replace('.', '_')

    offset = 0.05
    endpoints = []
    num_trajectories = len(trajectories)
    for i in range(num_trajectories):
        xs = []
        # Each of these arrays is of length 2 * max_t + 1
        # It contains max_t pairs of L(lambda_t, lambda_t) and L(lambda_{t-1}, lambda_t) in that order
        risks = []
        trajectory = trajectories[i]
        assert len(trajectory.risks_tt) == len(trajectory.risks_tm1_t) + 1
        for j in range(len(trajectory.risks_tt)):
            xs.append(j - offset)
            risks.append(trajectory.risks_tt[j])
            if j < len(trajectory.risks_tm1_t):
                xs.append(j + offset)
                risks.append(trajectory.risks_tm1_t[j])
            else:
                endpoints.append((j - offset, trajectory.risks_tt[j]))
        label = _tau_label(tau) if i == 0 and show_tau_in_legend else None
        plt.plot(xs, risks, color=color, alpha=min(1, 10. / num_trajectories), linewidth=0.5, label=label)
    plt.scatter(*zip(*endpoints), color=color, alpha=min(1, 10. / num_trajectories), marker='x', s=50)

    plt.axhline(args.alpha, linestyle='--', color='red', label=r'Upper bound $\alpha$')
    plt.axhline(args.alpha - args.tightness, linestyle='--', color='green', label=r'Lower Bound $\alpha - \Delta\alpha$')

    plt.xlabel("Iteration", fontsize=20)
    plt.ylabel("Risk", fontsize=20)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    # plt.ylim(0, 0.5)
    plt.legend(loc='lower right')
    # --- dynamic y-lims with padding so points at 0 aren't clipped ---
    all_y = []
    # collect risks you just plotted
    all_y.extend(risks)  # from the last loop scope; safer to collect within the loop:
    # (Better) collect during plotting:
    #   create all_y = [] before the 'for i in range(num_trajectories)' loop,
    #   then extend(all_y, risks) inside that loop.

    # include reference lines in range
    all_y.extend([args.alpha, args.alpha - args.tightness])

    if all_y:
        y_max = float(np.max(all_y))
    else:
        y_max = 1.0

    pad = max(1e-3, 0.05 * y_max)    # 5% headroom
    plt.ylim(-pad, y_max + pad)
    for lh in plt.gca().get_legend().legend_handles:
        lh.set_alpha(1)
    plt.grid(True)
    plt.tight_layout()
    if save_dir:
        save_path = os.path.join(save_dir, f"loss_vs_iteration_{tau_str}.pdf")
        plt.savefig(save_path, dpi=300)
        print(f"Saved loss plot to {save_path}")


def plot_final_loss_vs_iteration(
    taus: List[float],
    tau_trajectories: List[List[Trajectory]],
    colors: List[str],
    args,
    save_dir: str = "./figures"
):
    if save_dir:
        os.makedirs(save_dir, exist_ok=True)

    end_risks = []
    for trajectories in tau_trajectories:
        end_risks_tau = []
        for trajectory in trajectories:
            end_risks_tau.append(trajectory.risks_tt[-1])
        end_risks.append(end_risks_tau)

    x_indices = np.arange(len(taus))

    plt.figure(figsize=(7, 4))

    for i, index in enumerate(x_indices):
        y_values = end_risks[i]
        x_values = [index] * len(y_values)  # Repeat index for each end_risk value
        plt.scatter(x_values, y_values, marker='x', color=colors[i], alpha=min(1, 10. / len(trajectories)), s=50)
    plt.xticks(x_indices, taus, fontsize=14)
    plt.yticks(fontsize=14)
    plt.axhline(args.alpha, linestyle='--', color='#d62728', label=r'Upper Bound $\alpha$', linewidth=1.5)  # red
    plt.axhline(args.alpha - args.tightness, linestyle='--', color='#2ca02c', label=r'Lower Bound $\alpha - \Delta\alpha$', linewidth=1.5)  # green

    plt.xlabel(rf"$\tau$", fontsize=20)
    plt.ylabel("Risk", fontsize=20)

    all_risks = [r for sublist in end_risks for r in sublist]
    all_risks = [r for sublist in end_risks for r in sublist]
    ymax_data = max(all_risks) if all_risks else 1.0
    # also respect your bound lines
    ymax_bound = args.alpha + max(0.0, args.tightness * 0.5)
    y_max = max(ymax_data, ymax_bound)

    pad = max(1e-3, 0.05 * y_max)   # 5% headroom
    plt.ylim(-pad, y_max + pad)     # allow small negative so markers at 0 show fully

    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    if save_dir:
        save_path = os.path.join(save_dir, "final_loss_vs_tau.pdf")
        plt.savefig(save_path, dpi=300)
        print(f"Saved final loss plot to {save_path}")

    in_bounds = []
    out_of_bounds = []
    for end_risks_tau in end_risks:
        in_bounds.append(0)
        out_of_bounds.append(0)
        for end_risk in end_risks_tau:
            if args.alpha - args.tightness <= end_risk <= args.alpha:
                in_bounds[-1] += 1
            else:
                out_of_bounds[-1] += 1

    total = [i + o for i, o in zip(in_bounds, out_of_bounds)]
    in_bounds_frac = [i / t if t > 0 else 0 for i, t in zip(in_bounds, total)]
    out_of_bounds_frac = [o / t if t > 0 else 0 for o, t in zip(out_of_bounds, total)]

    n_groups = len(taus)

    fig, ax = plt.subplots(figsize=(7, 4))

    bar_width = 0.35
    index = np.arange(n_groups)

    # Plot bars
    rects1 = ax.bar(index, in_bounds_frac, bar_width,
                    label='In Bounds', color='#2ca02c')

    rects2 = ax.bar(index + bar_width, out_of_bounds_frac, bar_width,
                    label='Out of Bounds', color='#d62728')

    ax.axhline(args.delta, linestyle='--', color='#1f77b4', label=r'Failure Probability $\delta$', linewidth=1.5)

    # Add labels, title, and ticks
    ax.set_xlabel(rf"$\tau$", fontsize=20)
    ax.set_ylabel('Relative Frequency', fontsize=20)
    ax.set_xticks(index + bar_width / 2)
    ax.set_xticklabels(taus)
    ax.tick_params(axis='x', labelsize=14)
    ax.tick_params(axis='y', labelsize=14)
    ax.legend()

    ymax_bar = max(in_bounds_frac + out_of_bounds_frac + [args.delta]) + 0.05
    ax.set_ylim(0, ymax_bar)

    plt.tight_layout()
    if save_dir:
        save_path = os.path.join(save_dir, "failure_prob_vs_tau.pdf")
        plt.savefig(save_path, dpi=300)
        print(f"Saved final loss plot to {save_path}")
